<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>Taça Libertadores em Partículas — 3D de verdade</title>
  <style>
    body{margin:0;overflow:hidden;background:#000;font-family:Arial,sans-serif;color:#fff}
    #info{position:absolute;top:16px;left:16px;z-index:10;padding:8px 14px;border-radius:10px;
      background:rgba(0,0,0,.5);border:1px solid rgba(255,255,255,.12);font-size:13px;letter-spacing:.5px;user-select:none}
  </style>
</head>
<body>

<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
/* ===== Setup ===== */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 2000);
camera.position.set(0, 2.2, 14);

const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:'high-performance' });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.outputEncoding = THREE.sRGBEncoding;
document.body.appendChild(renderer.domElement);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

scene.add(new THREE.AmbientLight(0xffffff, 0.35));
const key = new THREE.PointLight(0xffffff, 1.2, 200);
key.position.set(12, 14, 12);
scene.add(key);

/* ===== Utils ===== */
const _vA=new THREE.Vector3(),_vB=new THREE.Vector3(),_vC=new THREE.Vector3();
const _v1=new THREE.Vector3(),_v2=new THREE.Vector3(),_v3=new THREE.Vector3();

function sampleSurface(geometry, count, matrix){
  const geo = geometry.index ? geometry.toNonIndexed() : geometry.clone();
  const pos = geo.getAttribute('position');
  const tris = pos.count/3;
  const areas = new Float32Array(tris);
  let total=0;
  for(let i=0;i<tris;i++){
    _vA.fromBufferAttribute(pos,i*3+0);
    _vB.fromBufferAttribute(pos,i*3+1);
    _vC.fromBufferAttribute(pos,i*3+2);
    _v1.subVectors(_vB,_vA);
    _v2.subVectors(_vC,_vA);
    const area=_v1.cross(_v2).length()*0.5;
    areas[i]=area; total+=area;
  }
  for(let i=1;i<tris;i++) areas[i]+=areas[i-1];

  const out=new Float32Array(count*3);
  for(let i=0;i<count;i++){
    const r=Math.random()*total; let lo=0,hi=tris-1;
    while(lo<hi){ const mid=(lo+hi)>>1; (r<=areas[mid])?hi=mid:lo=mid+1; }
    const t=lo;
    _vA.fromBufferAttribute(pos,t*3+0);
    _vB.fromBufferAttribute(pos,t*3+1);
    _vC.fromBufferAttribute(pos,t*3+2);
    let u=Math.random(), v=Math.random(); if(u+v>1){u=1-u; v=1-v;}
    _v1.copy(_vB).sub(_vA).multiplyScalar(u);
    _v2.copy(_vC).sub(_vA).multiplyScalar(v);
    _v3.copy(_vA).add(_v1).add(_v2);
    if(matrix) _v3.applyMatrix4(matrix);
    out[i*3]=_v3.x; out[i*3+1]=_v3.y; out[i*3+2]=_v3.z;
  }
  return out;
}

const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/circle.png');

function pointsFrom(geometry,{
  count, color=0xffffff, size=0.06, opacity=0.95, matrix=null,
  additive=false, depthWrite=true
}){
  const positions=sampleSurface(geometry,count,matrix);
  const g=new THREE.BufferGeometry();
  g.setAttribute('position', new THREE.BufferAttribute(positions,3));
  const m=new THREE.PointsMaterial({
    map:sprite, color, size, transparent: opacity < 1, opacity,
    depthWrite, sizeAttenuation:true,
    blending: additive ? THREE.AdditiveBlending : THREE.NormalBlending
  });
  return new THREE.Points(g,m);
}
function trs({x=0,y=0,z=0,rx=0,ry=0,rz=0,sx=1,sy=1,sz=1}){
  const mat=new THREE.Matrix4();
  mat.compose(new THREE.Vector3(x,y,z),
              new THREE.Quaternion().setFromEuler(new THREE.Euler(rx,ry,rz)),
              new THREE.Vector3(sx,sy,sz));
  return mat;
}

/* ===== Taça ===== */
const trophy = new THREE.Group(); scene.add(trophy);
const SILVER=0xeaf3ff, STEEL=0xbfd9ff, WOOD=0x6e3a24;

/* --- Base tambor + rodapé --- */
const baseH = 2.8, baseR = 1.80;
const baseGeo = new THREE.CylinderGeometry(baseR*0.985, baseR, baseH, 120, 1, true);
trophy.add(pointsFrom(baseGeo,{count:5600,color:WOOD,size:0.06,matrix:trs({y:-2.6+baseH/2}), additive:false, depthWrite:true}));

// rodapé (cilindro mais baixo e mais largo)
const foot = new THREE.CylinderGeometry(baseR*1.06, baseR*1.12, 0.25, 96, 1, true);
trophy.add(pointsFrom(foot,{count:1400,color:WOOD,size:0.06,matrix:trs({y:-2.6+0.12}), additive:false, depthWrite:true}));

// bandas 3D (substituem os torus) — topo e fundo
function addBand(y, radius, h=0.10, color=STEEL, count=900, size=0.055){
  const band = new THREE.CylinderGeometry(radius, radius, h, 120, 1, true);
  trophy.add(pointsFrom(band,{count,color,size,matrix:trs({y}), additive:false, depthWrite:true}));
}
addBand(-2.6+0.10, baseR*0.99);                         // borda inferior
addBand(-2.6+baseH-0.10, baseR*0.99);                   // borda superior

// linhas horizontais entre fileiras (bandas finas de 3D)
for(let i=1;i<=6;i++){
  const y = -2.6 + (i*baseH/7);
  addBand(y, baseR*0.985, 0.06, STEEL, 700, 0.052);
}

// montantes verticais (9 colunas) — barras finas
const cols=9, rows=7;
for(let c=0;c<cols;c++){
  const ang = (c/cols)*Math.PI*2;
  const bar = new THREE.CylinderGeometry(0.03,0.03,baseH-0.32, 8,1,true);
  const mat = new THREE.Matrix4().multiply(trs({ry:ang})).multiply(trs({x:baseR*0.985,y:-2.6+baseH/2}));
  trophy.add(pointsFrom(bar,{count:250,color:STEEL,size:0.05,matrix:mat, additive:false, depthWrite:true}));
}

// plaquetas 9×7
const plaqueW=0.34, plaqueH=0.145, plaqueT=0.02, plaqueR=baseR*0.985;
for(let r=0;r<rows;r++){
  const y = -2.6 + 0.18 + r*((baseH-0.36)/(rows-1));
  for(let c=0;c<cols;c++){
    const ang = (c/cols)*Math.PI*2 + 0.005*Math.sin(r*0.7);
    const box = new THREE.BoxGeometry(plaqueW, plaqueH, plaqueT);
    const mat = new THREE.Matrix4().multiply(trs({ry:ang})).multiply(trs({x:plaqueR,y}));
    trophy.add(pointsFrom(box,{count:170,color:STEEL,size:0.05,matrix:mat, additive:false, depthWrite:true}));
  }
}

// rebordo superior metálico (também como banda 3D)
addBand(-0.15, 1.74, 0.12, STEEL, 1000, 0.055);

/* --- Coluna e gola --- */
const columnGeo = new THREE.CylinderGeometry(1.05, 1.35, 0.85, 80, 1, true);
trophy.add(pointsFrom(columnGeo,{count:1800,color:SILVER,size:0.058,matrix:trs({y:0.12}), additive:false, depthWrite:true}));
addBand(0.60, 0.98, 0.10, STEEL, 800, 0.055);

const neckGeo = new THREE.CylinderGeometry(0.78, 1.0, 0.56, 64, 1, true);
trophy.add(pointsFrom(neckGeo,{count:1250,color:SILVER,size:0.056,matrix:trs({y:0.98}), additive:false, depthWrite:true}));

/* --- Tulipa (Lathe) + tampa/banda --- */
const profile = [
  new THREE.Vector2(0.62, 1.16),
  new THREE.Vector2(0.86, 1.28),
  new THREE.Vector2(1.14, 1.46),
  new THREE.Vector2(1.07, 1.60),
  new THREE.Vector2(0.93, 1.72),
  new THREE.Vector2(0.74, 1.86),
];
const latheGeo = new THREE.LatheGeometry(profile, 180);
trophy.add(pointsFrom(latheGeo,{count:3200,color:SILVER,size:0.058, additive:false, depthWrite:true}));
addBand(1.88, 0.99, 0.08, STEEL, 760, 0.052);
const cap = new THREE.CylinderGeometry(0.86,0.95,0.14,64,1,true);
trophy.add(pointsFrom(cap,{count:760,color:SILVER,size:0.052,matrix:trs({y:1.97}), additive:false, depthWrite:true}));

/* --- Globo + cinturão --- */
const globeR=1.28, globeY=1.97+globeR+0.02;
const globe = new THREE.SphereGeometry(globeR, 72, 72);
trophy.add(pointsFrom(globe,{count:4600,color:SILVER,size:0.06,matrix:trs({y:globeY}), additive:false, depthWrite:true}));

const belt = new THREE.CylinderGeometry(globeR*0.97, globeR*0.97, 0.22, 120, 1, true);
trophy.add(pointsFrom(belt,{count:1600,color:STEEL,size:0.058,matrix:trs({y:globeY}), additive:false, depthWrite:true}));

/* --- Alças (curva em S) --- */
function handleCurve(side=1){
  const y0 = globeY;
  const x0 = side*(globeR+0.03);
  const pts = [
    new THREE.Vector3(x0, y0-0.45, 0.00),
    new THREE.Vector3(x0+side*0.30, y0-0.25, 0.18),
    new THREE.Vector3(x0+side*0.40, y0+0.10, 0.12),
    new THREE.Vector3(x0+side*0.28, y0+0.35, 0.00),
    new THREE.Vector3(x0, y0+0.45, 0.00),
  ];
  return new THREE.CatmullRomCurve3(pts,false,'catmullrom',0.0);
}
function addHandle(side){
  const tube = new THREE.TubeGeometry(handleCurve(side), 160, 0.065, 16, false);
  trophy.add(pointsFrom(tube,{count:1900,color:SILVER,size:0.055, additive:false, depthWrite:true}));
  const lug = new THREE.CylinderGeometry(0.10,0.10,0.12,16,1,true);
  trophy.add(pointsFrom(lug,{count:130,color:SILVER,size:0.052,matrix:trs({x:side*(globeR+0.02), y:globeY+0.45}), additive:false, depthWrite:true}));
  trophy.add(pointsFrom(lug,{count:130,color:SILVER,size:0.052,matrix:trs({x:side*(globeR+0.02), y:globeY-0.45}), additive:false, depthWrite:true}));
}
addHandle(+1); addHandle(-1);

/* --- Mini-estátua --- */
const topY = globeY + globeR + 0.60;
trophy.add(pointsFrom(new THREE.CylinderGeometry(0.085,0.085,0.56,24,1,true),{
  count:540,color:SILVER,size:0.048,matrix:trs({y:topY}), additive:false, depthWrite:true
}));
trophy.add(pointsFrom(new THREE.SphereGeometry(0.12,24,24),{
  count:330,color:SILVER,size:0.047,matrix:trs({y:topY+0.35}), additive:false, depthWrite:true
}));
const arm = new THREE.CylinderGeometry(0.05,0.05,0.5,16,1,true); arm.rotateZ(Math.PI/2);
trophy.add(pointsFrom(arm,{count:360,color:SILVER,size:0.047,matrix:trs({y:topY+0.18,x:0.12}), additive:false, depthWrite:true}));
trophy.add(pointsFrom(new THREE.SphereGeometry(0.10,20,20),{
  count:240,color:SILVER,size:0.045,matrix:trs({y:topY+0.18,x:0.40}), additive:false, depthWrite:true
}));

/* --- Fundo (estrelas com brilho) --- */
const stars=(()=>{
  const g=new THREE.BufferGeometry(); const N=1000; const p=new Float32Array(N*3);
  for(let i=0;i<N;i++){
    const r=60+Math.random()*45, th=Math.random()*Math.PI*2, ph=Math.acos(2*Math.random()-1);
    p[i*3]=r*Math.sin(ph)*Math.cos(th); p[i*3+1]=r*Math.sin(ph)*Math.sin(th); p[i*3+2]=r*Math.cos(ph);
  }
  g.setAttribute('position', new THREE.BufferAttribute(p,3));
  const m=new THREE.PointsMaterial({
    map:sprite,size:.55,color:0x9ecbff,transparent:true,opacity:.28,
    depthWrite:false,sizeAttenuation:true,blending:THREE.AdditiveBlending
  });
  const pts=new THREE.Points(g,m); scene.add(pts); return pts;
})();

/* ===== Animação ===== */
const clock=new THREE.Clock();
trophy.children.forEach(o=>{ if(o.isPoints) o.material.sizeBase=o.material.size; });

function animate(){
  requestAnimationFrame(animate);
  const t=clock.getElapsedTime();
  trophy.rotation.y += 0.0016;
  trophy.children.forEach(o=>{
    if(o.isPoints && o.material && o.material.sizeBase){
      o.material.size = o.material.sizeBase * (1 + Math.sin(t*2 + o.id)*0.02);
    }
  });
  stars.rotation.y += 0.00035;
  controls.update();
  renderer.render(scene,camera);
}
animate();

addEventListener('resize', ()=>{
  camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
